在本章中，先修内容有：
- 动态规划的四要素
	- 动态规划的状态
	- 动态规划的方程
	- 动态规划的初始化
	- 动态规划的答案
- 坐标型动态规划
	- 例题：Lintcode114 不同的路径
	
课后补充内容有
- 背包问题
- 双序列型动态规划
- 序列型动态规划高频题：最长上升子序列

首先我们用一个例子来讲解以下动态规划的四要素：状态、方程、初始化、答案

# dp的四要素
我们先通过一个通过一个例题上节课的一个例题，来讲解动态规划的四要素

https://www.lintcode.com/problem/min-cost-climbing-stairs/description

## 题意描述
在楼梯上，每一号台阶都有各自的费用，即第 i 号台阶有非负成本cost [i]（台阶从0号索引）。

你可以爬一到两步，如果你到达了某个台阶，你需要支付到达这个台阶的费用。 你需要找到最低成本来到达最高层，你可以从索引为0的楼梯开始，也可以从索引为1的楼梯开始。

最高层不需要费用。

在这道爬楼梯的题中，我们该如何使用动态规划的四要素来思考这个问题呢？

# 动态规划的状态
## 题意描述
在楼梯上，每一号台阶都有各自的费用，即第 i 号台阶有非负成本cost [i]（台阶从0号索引）。

你可以爬一到两步，如果你到达了某个台阶，你需要支付到达这个台阶的费用。 你需要找到最低成本来到达最高层，你可以从索引为0的楼梯开始，也可以从索引为1的楼梯开始。

最高层不需要费用。

## 确定动态规划的状态
- 用`f[i]`或者`f[i][j]`代表在某些特定条件下某个规模更小的问题的答案
- 动态规划的规模由i，j的大小来划定
确定状态的目标就是，确定`f[i]`或`f[i][j]`中的值是什么，以及i和j是什么。

所以在这道题中，我们想要求的就是在**到达每个台阶时的最小费用**，那么这个最小费用就是f数组中的值，而i就是到达的台阶（特定条件）。

到这一步我们就已经确定了这道题动态规划的状态

# 动态规划的方程
## 题意描述
在楼梯上，每一号台阶都有各自的费用，即第 i 号台阶有非负成本cost [i]（台阶从0号索引）。

你可以爬一到两步，如果你到达了某个台阶，你需要支付到达这个台阶的费用。 你需要找到最低成本来到达最高层，你可以从索引为0的楼梯开始，也可以从索引为1的楼梯开始。

最高层不需要费用。

## 找出动态规划的转移方程
在上一部分中，我们已经知道了我们要找的`f[i]`代表了走到第i级台阶的最小成本，那么我们现在就需要找到一个递推式，也就是如果用之前的**状态**推得现在的状态。

在这道题中我们发现，因为每一步只能走一步或两步，走到第10级台阶的最小总花费，是走到第九级台阶和第八级台阶的最小花费的较小值，加上走上第10级台阶的花费cost[10]。所以f[i]这个状态是由f[i-1]和f[i-2]这两个状态转移过来的。

也就是说 `f[i] = min(f[i-1], f[i-2]) + cost[i]`

这就是我们要的转移方程，只要知道了靠前的状态，就可以得出当前的状态值。

# 动态规划的初始化
## 题意描述
在楼梯上，每一号台阶都有各自的费用，即第 i 号台阶有非负成本cost [i]（台阶从0号索引）。

你可以爬一到两步，如果你到达了某个台阶，你需要支付到达这个台阶的费用。 你需要找到最低成本来到达最高层，你可以从索引为0的楼梯开始，也可以从索引为1的楼梯开始。

最高层不需要费用。

## 存在转移方程无法解决的点？ —— 初始化
我们在上一节中已经得到了动态规划的转移方程`f[i] = min(f[i-1], f[i-2]) + cost[i]`，但是我们去考虑当`i=0`时，会发现转移方程成了`f[0] = min(f[-1], f[-2]) + cost[i]`。这就很尴尬了，我们并没有`f[-1]`和`f[-2]`，甚至会造成数组越界。

所以，这个时候，我们就需要**初始化`f[0]`和`f[1]`的值**。那我们初始化成多少呢？我们会发现：

> 你需要找到最低成本来到达最高层，你可以从索引为0的楼梯开始，也可以从索引为1的楼梯开始。

所以我们到达第0个台阶的最小费用是cost[0]，到达第1级台阶的最小费用是cost[1]（其实是min(cost[0] + cost[1], cost[1])，所以我们直接用cost[1]就行了）

因此我们就有了
```
f[0] = cost[0];
f[1] = cost[1];
for (int i = 2; i < n; i++){
    f[i] = min(f[i-1], f[i-2]) + cost[i];
}
```

# 动态规划的答案
## 题意描述
在楼梯上，每一号台阶都有各自的费用，即第 i 号台阶有非负成本cost [i]（台阶从0号索引）。

你可以爬一到两步，如果你到达了某个台阶，你需要支付到达这个台阶的费用。你需要找到最低成本来到达最高层，你可以从索引为0的楼梯开始，也可以从索引为1的楼梯开始。

最高层不需要费用。

经过前三步，我们已经完美地算出了所有的f[i]，但是我们最终的结果是多少呢，也就是这个问题的返回值是多少？

假设最高层为第n层，那么因为第n层只能从第n-1层和第n-2层到达，且不需要费用，因此答案显然就是 min(f[n-1], f[n-2]) ,我们最后的答案就是 min(f[n-1], f[n-2])

因此我们就有了
```
return min(f[n-1],f[n-2]);
```
至此，这道题就完全被解决了。

你可以自己试着做这道题来复习一下每个步骤。

接下来，我们就再看一下一种面试中最常见的动态规划类型：坐标型动态规划的解题思路

# 坐标型动态规划
坐标型动态规划指的是，在一个具有坐标的数据结构中（一般是矩阵）进行动态规划的题目，在这种题目中，f[i][j]中的i,j一般指的是坐标(i,j)，转移方程则根据每个点的可达点来定义即可。

我们来看一道例题来了解一下坐标型动态规划的解题步骤

# 坐标型动态规划例题：[114. 不同的路径](https://www.lintcode.com/problem/unique-paths/description)
## 题意描述
有一个机器人的位于一个 m × n 个网格左上角。

机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。

问有多少条不同的路径？

其中：

n和m均不超过100

且答案保证在32位整数可表示范围内。

## 解题思路
有同学看到这个问题可能会想到dfs，从起点往终点dfs，每次往下或者往右走，走到终点就说明有一条可行的路径。

但是这样的话，其实时间复杂度是指数级别的，相当于每一次都有两个选择（往下or往右）。在n，m较大的情况下，显然这个时间复杂度是无法接受的。

我们发现，这道题并不需要我们求出所有的路径具体是什么，只要求这个路径的数量是多少，那么我们就考虑用动态规划来解决这道题。

### 动态规划的状态
> 求什么状态就是什么

这道题中，我们求的是**多少条路径**，而路径量只与终点的坐标有关。

> 坐标型动态规划的f[i][j]的i和j一般代表了坐标。

所以我们可以得出，f[i][j]代表了，从起点到(i,j)这个点有多少条路径。

### 动态规划的方程
那我们该怎么找到这个转移方程呢。

我们去考虑，到每个点的路径数是如何求得的。举个例子，我们从起点(0,0)走到(2,5)有10条完全不同的路径，走到(3,4)共有20条不同的路径，那么我们走到(3,5)有多少条不同的路径呢？

应该是有10+20条不同的路径。如果我们有10条走到（2，5）的不同路径，那么我们只需要在这些路径后加一个往下走一步就可以获得10条走到（3，5）的不同路径（假设往下走会增加第一维坐标，往右走会增加第二维坐标）。同理，我们只需要在20条走到（3，4）的路径后面加一个往右走一步，这20条路径仍是不同的，且它们都能到达（3，5）这个点。

那么我们就得到了转移方程 f[i][j] = f[i - 1][j] + f[i][j - 1]

### 动态规划的初始化
既然我们得到了转移方程，那么哪些点是不能通过转移方程得到的呢？

我们发现，如果i=0，或者j=0，也就是第一行和第一列的元素，如果代入转移方程会导致数组越界。

因此我们要将这些点先进行初始化。对于这些点，比如第一行的点，我们只能通过一直向右走到达；对于第一列的点，我们只能通过一直向下走来到达。那么对于这些点来说，能到达这些点的只有一条路径。

因此有
```
for (int i = 0; i < n; i++){
    dp[i][0] = 1;
}

for (int j = 0; j < n; j++){
    dp[0][j] = 1;
}
```
### 动态规划的答案
我们要求的是从（0，0）走到（n - 1，m - 1）的所有路径，而刚好f[n-1][m-1]就代表这个答案，并且在之前的过程中已经求得了。我们直接发挥f[n-1][m-1]即可。

以上就是课程的先修内容，同学们可以继续学习以下补充内容

# 背包问题
背包是一个面试中非常常见的考点，也是一个比较大的难点。题型多变，有0-1背包，多重背包，完全背包等等，同时还有各种空间复杂度的优化方法。大家可以点击下面的课程，进入试听课了解0-1背包的基础知识。主要内容有
- 0-1背包的定义
- 为什么无法用贪心的思路解决背包问题
- 如何使用动态规划解决背包问题
- 0-1背包例题Lintcode 92讲解
- 0-1背包例题Lintcode 563讲解

我们之前学习了如果用记忆化搜索的方法解决区间型动态规划问题，那么能否用动态规划的思路解决区间型动态规划问题呢？

# 区间型动态规划例题：[476. 石子归并](https://www.lintcode.com/problem/stone-game/description)
## 题意描述：
有一个石子归并的游戏。最开始的时候，有n堆石子排成一列，目标是要将所有的石子合并成一堆。合并规则如下：
- 每一次可以合并相邻位置的两堆石子
- 每次合并的代价为所合并的两堆石子的重量之和

求出最小的合并代价。

## 解题思路
这道题我们在上一章已经用了递归，也就是记忆化搜索的方法做出了这道题。我们这次来讲一下如何用非递归的方式来做这道题，如果同学们对这道题的记忆化搜索做法还有疑问，可以返回第8章的补充内容自学了解。

首先我们也是从dp的四要素来看

### 动态规划的状态
这里我们仍然沿用记忆化搜索的思路，用f[i][j]代表将区间(i,j)内的所有石子合为一堆所需要的最少花费。

### 动态规划的方程
这里仍然是以记忆化搜索的思路，一个大的区间一定是由两个小区间合并而来的，因此有f[i][j] = f[i][k] + f[k + 1][j] + sum(i,j),其中sum[i][j]代表区间[i,j]中所有石子重量之和。

### 动态规划的初始化
这一部分，我们知道将1堆石子合并为一堆，不需要任何的花费，因此f[i][i] = 0

### 动态规划的结果
假如共有n堆石子，那么我们所求的是将[0,n-1]区间内所有石子合为一堆的花费。也就是f[0][n-1]

## 参考代码
Python:
```
class Solution:
    def stoneGame(self, A):
        n = len(A)
        if n < 2 :
            return 0
        dp = [[0 for i in range(n)] for j in range(n)]
        sum = [0 for i in range(n)]

        for i in range(n):
            dp[i][i] = 0

        sum[0] = A[0]
        for i in range (1, n):
            sum[i] = sum[i - 1] + A[i]
            
        for x in range(2, n+1):
        # x 为区间长度
            for i in range(n - x + 1):
                j = i+x-1
                # j为区间终点
                dp[i][j] = sys.maxsize
                for k in range(i, j):
                    t = dp[i][k] + dp[k+1][j] + sum[j]
                    if(i != 0):
                        t -= sum[i - 1]
                    dp[i][j] = min(dp[i][j], t)
        return dp[0][n-1]
```
Java:
```
public class Solution {
    /**
     * @param A an integer array
     * @return an integer
     */
    public int stoneGame(int[] A) {
        // Write your code here
        
    
        int n = A.length;
        
        if (n < 2){
            return 0;
        }   
            
        int[][] f = new int[n][n];
        int[]sum = new int[n + 1]; 

        for (int i = 0; i < n; i++){
            f[i][i] = 0;
        }
        sum[0] = A[0];
        for (int i = 1; i<= n; i++){
            sum[i] = sum[i - 1] + A[i - 1];
        }
            
            
        for (int x = 2; x <= n; x++){
            // x 为区间长度
            for(int i = 0; i < n - x + 1; i++){
                int j = i+x-1;
                // j为区间终点
                f[i][j] = Integer.MAX_VALUE;
                for (int k = i; k < j; k++){
                    int t = f[i][k] + f[k+1][j] + sum[j + 1] - sum[i];
                    f[i][j] = Math.min(f[i][j], t);
                }
            }
                
        }
            
        return f[0][n-1];
    }
}
```

石子归并这个问题还有一种可以将时间复杂度优化到O(n^2)的优化方法，叫平行四边形优化，对算法有兴趣的同学可以了解以下，但是面试99.99999%不会考这个优化方法。

https://blog.csdn.net/lmyclever/article/details/6677683

# 双序列型动态规划例题：[77. Longest Common Subsequence](https://www.lintcode.com/problem/longest-common-subsequence/description)
这也是一个我们在上一章已经讲过如何用记忆化搜索实现的问题，在这一章我们仍然是来看一下，如何使用非递归的方法来做出这道题。

## 题意描述
给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。如A = "ABCD", B = "EACB"，其最长公共子序列就是"AC"。

## 解题思路
### 动态规划的状态
在这道题中，我们使用f[i][j]代表字符串A的前i个字符与字符串B的前j个字符组成的最长公共子序列（LCS）的长度。

### 动态规划的方程
记A[:n]为字符串A的前n个字符，B[:m]为字符串B的前m个字符，则A的第n个字符与B的第m个字符，A[:n]与B[:m]的最长公共子序列长度就相当于A[:n - 1]与B[:m - 1]的最长公共子序列长度 + 1；若A的第n个字符与B的第m个不同，那它们的最长公共子序列长度，必然是A[:n - 1]与B[:m]的最长公共子序列长度和A[:n]与B[:m - 1]的最长公共子序列长度的最大值。

所以我们有当A[i] != A[j] 时f[i][j] = max(f[i][j-1], f[i-1][j]),若A[i] == A[j] ，则有f[i][j] = f[i-1][j-1] + 1

这就是我们的转移方程。

### 动态规划的初始化
我们发现当i = 0 或 j = 0时会出现数据越界,因此得对它们进行一些初始化。

假如i = 0，相当于拿A的前0个字符与字符串B中的j个字符找它们的LCS，这样LCS的最长子序列长度必然为0，j = 0情况同理。

因此我们有
```
for(int i = 0; i < n; i++){
    f[i][0] = 0;
}
for(int j = 0; j < m; j++){
    f[0][j] = 0;
}
```
### 动态规划的答案
那么我们发现f[n-1][m-1]就是使用A中的所有字符和B中的所有字符的最长公共子序列长度。

Java:
```
public class Solution {
    public int longestCommonSubsequence(String A, String B) {
        if (A == null || B == null) {
            return 0;
        }
        int lenA = A.length();
        int lenB = B.length();
        if (lenA == 0 || lenB == 0) {
            return 0;
        }
        
        int[][] f = new int[lenA + 1][lenB + 1];
        
        for (int i = 1; i <= lenA; i++) {
            for (int j = 1; j <= lenB; j++) {
                f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]);
                if (A.charAt(i - 1) == B.charAt(j - 1)) {
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);
                }
            }
        }
        
        return f[lenA][lenB];
    }
}
```

Python:
```
class Solution:
    def longestCommonSubsequence(self, A, B):
        n, m = len(A), len(B)
        f = [[0] * (n + 1) for i in range(m + 1)]
        for i in range(n):
            for j in range(m):
                f[i + 1][j + 1] = max(f[i][j + 1], f[i + 1][j])
                if A[i] == B[j]:
                    f[i + 1][j + 1] = f[i][j] + 1
        return f[n][m]
```

# 序列型动态规划：[76. 最长上升子序列](https://www.lintcode.com/problem/longest-increasing-subsequence/description)
## 题意介绍
给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。

最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。

https://en.wikipedia.org/wiki/Longest_increasing_subsequence

## 解题思路：
### 动态规划的状态
首先我们要考虑动态规划的状态。在这道题中，我们用f[i]来代表以第i个数字为结尾的最长上升子序列的长度。比如，以[4,2,4,5,3,7]为例，则f数组的值为[1,1,2,3,2,4]

### 动态规划的转移方程
为什么我们要把f数组定义为以第i个数字为结尾的最长上升子序列长度呢？因为这样在我们进行转移时，如果当前元素为5，则若A[i] = 3， dp[i] = 2，也就是说有一个以3结尾的长度为2的上升子序列，那么我只要在这个序列后加一个5，就获得了以当前该元素5结尾，长度为3个上升子序列。

因此我们可以对于每个数字，枚举前面所有小于自己的数字 j，f[i] = max{f[j]} + 1. 如果没有比自己小的，f[i] = 1;

### 动态规划的初始化
在这道题中，我们发现并不需要初始化，因为并没有哪个状态是无法用转移方程计算的

### 动态规划的答案
那我们最终的答案是什么呢？

有些同学可能会想，是f[n - 1]。这里的f[n - 1]指的不是[0, n - 1]这个序列的LIS长度，而是指的是以第n-1个元素作为最后一个元素的LIS长度。但是我们的LIS一定是以最后一个元素为结尾吗？显然不一定。比如[1,2,3,4,1],这个序列，它的f数组为[1,2,3,4,1]，以最后一个元素为结尾，只能找到[1], 而以4结尾，则可以找到[1,2,3,4]，因此我们找的是所有f[i]中的最大值。

## 参考代码
Java:
```
public class Solution {
    public int longestIncreasingSubsequence(int[] nums) {
        int []f = new int[nums.length];
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            f[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    f[i] = f[i] > f[j] + 1 ? f[i] : f[j] + 1;
                }
            }
            if (f[i] > max) {
                max = f[i];
            }
        }
        return max;
    }
}
```
Python:
```
class Solution:
    def longestIncreasingSubsequence(self, nums):
        if nums is None or not nums:
            return 0
        dp = [1] * len(nums)
        for curr, val in enumerate(nums):
            for prev in range(curr):
                if nums[prev] < val:
                    dp[curr] = max(dp[curr], dp[prev] + 1)
        return max(dp)
```

# LIS的O(nlogn)优化
## 思路解析
在我们之前的做法中，我们做了许多的重复的运算，例如

`i: [0, 1, 2, 3, 4]`

`A: [1, 5, 2, 6, 2]`

`f: [1, 2, 2, 3, 2]`

例如，当i = 3时，我们的操作是
```
A[3] > A[0] ==> f[3] = A[0] + 1 = 2;
A[3] > A[1] ==> f[3] = A[1] + 1 = 3;
A[3] > A[2] ==> f[3] = A[2] + 1 = 3;
```
我们会发现A[3]与A[2]的比较并不会对结果产生影响，也就是说f函数值相同的index，我们其实只需要记其最小的元素的大小即可。

我们考虑使用一个辅助数组B，其中B[i]表示f数组中的值为i的最小整数，那么在i=3时，我们有

`i: [0, 1, 2, 3, 4]`

`A: [1, 5, 2, 6, 2]`

`f: [1, 2, 2, 3, 2]`

`B: [0, 1, 2, inf, inf]`

这里的inf表示无限大的数

我们的判断过程可以是
```
A[3] > B[0] ==> f[3] = 0 + 1 = 1
A[3] > B[1] ==> f[3] = 1 + 1 = 2
A[3] > B[2] ==> f[3] = 2 + 1 = 3

// 得到f[3] = 3;

B[3] = min(B[3], A[3])

// i = 4
// B: [0, 1, 2, 3, inf];

A[4] > B[0] ==> f[4] = 0 + 1 = 1
A[4] > B[1] ==> f[4] = 1 + 1 = 2
A[4] < B[2] ==> f[4] = 2;
```
也就是说，我们只要找到B数组中第一个大于A[i]的数字，即可知道f[i]的值是多少。f[i]的值就是B数组中第一个大于A[i]的数字的下标。

而B[i]是一个递增数组（可以自己证明），因此我们可以用二分的方法来解决这个问题。

