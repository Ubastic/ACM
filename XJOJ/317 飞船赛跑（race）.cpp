/*
题意看原题，注意是按x的升序给出数据的，省掉了排序这一步

所有的车一起出发，对于某一辆车而言，他最终能超过的车的个数是出发在他前面，并且车速比他小的
由于是按出发点的升序排列的
所以题的意思就是给一串数（v），把每个数右边比他大的个数加起来
这道题不需要读入x的数据
但是直接做的话时间复杂度是O(n^2)超时
幸好速度值小于100！！
一个车一个车的读入数据，用int times[100]存储某一个车速的车出现了多少次（这是出发点在该车之前的）
然后找比该车速度大的车的数量，加起来就行了
cin，cout也会超时，这道题本来不难，硬是被时间卡的

关键词：模拟，有思想，怕超时 
*/
#include<iostream>
using namespace std;

int main()
{
    int n,count=0;
    int v;
    int times[100]={0};//表示当前每个速度的车出现的次数 
    
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&v);
        scanf("%d",&v);
        for(int j=v+1;j<100;j++)
            count+=times[j]; 
        times[v]++;
        count%=1000000;
    }
    
    printf("%d",count);
    //while(1);
}
