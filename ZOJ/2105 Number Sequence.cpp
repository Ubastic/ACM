/*
数列f(1)=f(2)=1，f(n)=[A*f(n-1)+B*f(n-2)]%7。输入1<=A,B<=1000,1<=n<=100000000，求f(n)

由递推式可化简：A=A%7，B=B%7，并且该数列为周期不大于7^2=49的周期函数，所以n=n%f
A=0,B=0:1,1,0,0,0,0,0,0,0,0（特例 ） 
A=1,B=0:1,1,1,1,1,1,1,1,1,1（周期为1） 
A=2,B=0:1,1,2,4,1（周期为3） 
A=3,B=0:1,1,3,2,6,4,5,1（周期为6） 
A=4,B=0:1,1,4,2,1（周期为3） 
A=5,B=0:1,1,5,4,6,2,3,1（周期为6） 
A=6,B=0:1,1,6,1（周期为2） 
当B!=0时，数列以"1,1"组合为循环终点
预先算出A,B的49种情况下的周期并存下一周期内的数字，然后根据输入直接输出

关键词：巧算法，数学题 
*/
#include<iostream>
using namespace std;

int main()
{ 
    int a,b,n;
    int f1,f2,f3;
    int period[7][7]={0,1 ,6 ,12,6 ,12,4,
                      1,16,6 ,24,48,21,6,
                      3,6 ,48,6 ,48,24,1,
                      6,16,48,42,6 ,1 ,8,
                      3,16,48,21,1 ,6 ,8,
                      6,6 ,48,1 ,48,24,14,
                      2,16,1 ,24,48,42,3};//a,b的周期 
    int times[7][7][70]; 
    
    for(a=0;a<7;a++)
        for(b=0;b<7;b++)
        {
            times[a][b][1]=times[a][b][2]=1;
            f1=f2=1;
            for(n=3;n<70;n++)
            {
                times[a][b][n]=(a*f2+b*f1)%7;
                f1=f2;
                f2=times[a][b][n];
            }
        }    
        
    while(cin>>a>>b>>n)
    {
        if(n==0)break;
        
        a%=7;b%=7;
        
        if(n==1||n==2){cout<<"1"<<endl;continue;}
        if(a==0&&b==0){cout<<"0"<<endl;continue;}
        
        if(b==0)n=(n-2)%period[a][b]+2;
           else n=(n-1)%period[a][b]+1;
           
        cout<<times[a][b][n]<<endl;
    }
    
    return 0; 
}
