/*
有三块玻璃板叠在一起，从一面射入一束光线，要求经过0<=n<=60次反射后射出，求有几种反射组合

假设光从玻璃上方射入，第一次反射可以是在1,2,3的底面，共三种情况。
若是1，则第二次反射只能从1的顶面反射
若是2，则第二次反射可以从1,2的顶面反射
若是3，则第二次反射可以从1,2,3的顶面反射
继续，在从顶面反射来的光（向下射），和最初入射光方向一致，
所以若从1的顶面反射来的光，第三次反射有三种可能(1,2,3的底面)
若从2的顶面反射来的光，第三次反射有两种可能(2,3的底面)
若从3的顶面反射来的光，第三次反射只有一种可能(3的底面)
得出树状图规律，在光向下时，(1)对应1，(2)发散出1,2，(3)发散出1,2,3
在光向上时,(1)发散出1,2,3，(2)发散出2,3，(3)发散出1 
用数组temp[0],temp[1],temp[2]分别表示树状图中1,2,3在第n次反射时出现的次数，总和reflect[n]即为反射第n次的可能路径总和
--------------------------------------------------
反射次数    temp[0]    temp[1]    temp[2]    总和
--------------------------------------------------
    0          1         0          0         1
    1          1         1          1         3
    2          3         2          1         6
    3          3         5          6         14
    4          14        11         6         31
    5          14        25         31        70
    6          70        56         31        157
--------------------------------------------------
规律是temp里每一个数都等于上一行的数加上上一行的前一个数，不过对于奇数行是从左往右加，偶数行从右往左加
这是由于光在顶面反射和底面反射时1,2,3所表示的“下一次反射可能性”意义正好相反
因为当n>=55时，答案已超出unsigned long long类型，所以要加高精度

f[i]=f[i-2]-f[i-3]+2*f[i-1];也是一种方法 

关键词：难题，巧方法，树状图 
*/
#include <iostream> 
using namespace std; 

int main()
{ 
    int n,k;
    
    int reflect[61][30]={0};         //存下61个答案 
    int temp[3][30]={0};
    
    void plus(int *,int *,int *,int *);     //高精度加法，第一个数等于后三个数的和 
    void self_plus(int *,int *);            //高精度加法，第一个数自加第二个数 
    
    temp[0][0]=1;
    temp[1][0]=0;
    temp[2][0]=0;
    
    for(int i=0;i<62;i+=2)
    {
        plus(reflect[i],temp[0],temp[1],temp[2]);        //偶数行的答案 
        
        self_plus(temp[1],temp[0]);        //temp[1]=temp[0]+temp[1]; 
        self_plus(temp[2],temp[1]);        //奇数行从右往左加
        
        plus(reflect[i+1],temp[0],temp[1],temp[2]);      //奇数行的答案 
        
        self_plus(temp[1],temp[2]);        //temp[1]=temp[1]+temp[2];
        self_plus(temp[0],temp[1]);        //偶数行从左往右加 
    }
    
    //freopen("aaa.txt","r",stdin);
    
    while (cin>>n)
    {  
        for(k=29;reflect[n][k]==0;k--);   //排除掉高位的零 
        
        while(k>=0)
        {
            cout<<reflect[n][k];
            k--;
        }
        cout<<endl;
    } 
    
    //while(1);
    return 0; 
}


void plus(int answer[30],int a[30],int b[30],int c[30])
{
    for(int i=0;i<30;i++)            //每位相加
        answer[i]=a[i]+b[i]+c[i];    
        
    for(int i=0;i<29;i++)            //进位
    {
        answer[i+1]+=answer[i]/10;
        answer[i]%=10;
    }                                //两个for可以做些改动合起来 
}

void self_plus(int answer[30],int a[30])
{
    for(int i=0;i<30;i++)            //每位相加
        answer[i]+=a[i];
    
    for(int i=0;i<29;i++)            //进位
    {
        answer[i+1]+=answer[i]/10;
        answer[i]%=10;
    }
}
